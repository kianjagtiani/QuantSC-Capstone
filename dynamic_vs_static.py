# -*- coding: utf-8 -*-
"""dynamic_vs_static

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eItWB5Ss9wKuBAUQcwP-uiDwIkFJ2x2F
"""

# Dynamic vs Static Visualizer

import sys
!{sys.executable} -m pip install yfinance --quiet

import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt

# Params
start, end         = '2018-01-01', '2018-12-31'
initial_capital    = 10000
momentum_window    = 10
vix_threshold      = 15.0
δ, θ               = 0.10, 0.10

# Data
spx  = yf.download('^GSPC', start=start, end=end, progress=False)
upro = yf.download('UPRO', start=start, end=end, progress=False)
spxu = yf.download('SPXU', start=start, end=end, progress=False)
irx  = yf.download('^IRX', start=start, end=end, progress=False)

def calc_ret(df):
    col = 'Adj Close' if 'Adj Close' in df.columns else 'Close'
    return df[col].pct_change().dropna()

r_spx   = calc_ret(spx)
r_upro  = calc_ret(upro)
r_spxu  = calc_ret(spxu)
r_tbill = ((1 + calc_ret(irx)/100)**(1/252) - 1).reindex(r_spx.index).ffill()

# Initialize
mom = (1 + r_spx).rolling(momentum_window).apply(np.prod) - 1
vix = yf.download('^VIX', start=start, end=end, progress=False)['Close'] \
      .reindex(r_spx.index).ffill()

dates    = r_spx.index
n        = len(dates)
mom_arr  = mom.values
vix_arr  = vix.values
mom_arr[:momentum_window] = 0.0

# Statics
bw_static = np.full(n, 1/3)
br_static = np.full(n, 2/3)

# Dynamics
bw_dyn = np.zeros(n)
br_dyn = np.zeros(n)
for i in range(n):
    mi, vi = mom_arr[i], vix_arr[i]
    if (mi > 0) and (vi < vix_threshold):
        bw_dyn[i], br_dyn[i] = 1/3, 2/3    # net long
    elif (mi < 0) and (vi > vix_threshold):
        bw_dyn[i], br_dyn[i] = 2/3, 1/3    # net short
    else:
        bw_dyn[i], br_dyn[i] = 1/3, 2/3    # default

def run_strategy(bw_arr, br_arr):
    long_t     = np.zeros(n)
    short_bull = np.zeros(n)
    short_bear = np.zeros(n)
    port       = np.zeros(n)

    long_t[0]     = initial_capital
    short_bull[0] = bw_arr[0] * initial_capital
    short_bear[0] = br_arr[0] * initial_capital
    port[0]       = long_t[0] + short_bull[0] + short_bear[0]

    for i in range(1, n):
        # Momentum
        short_bull[i] = short_bull[i-1] * (1 - r_upro.iloc[i-1])
        short_bear[i] = short_bear[i-1] * (1 - r_spxu.iloc[i-1])
        long_t[i]     = long_t[i-1] * (1 + r_tbill.iloc[i-1])
        bw, br = bw_arr[i], br_arr[i]

        # rebalance
        tot_sh = short_bull[i] + short_bear[i]
        curr = short_bull[i] / tot_sh
        if (curr < bw - δ) or (curr > bw + δ):
            short_bull[i] = bw * tot_sh
            short_bear[i] = br * tot_sh

        # inflow/outflow
        tot_sh = short_bull[i] + short_bear[i]
        margin = long_t[i] / tot_sh
        if margin < (1 - θ):
            f = tot_sh / long_t[i]
            short_bull[i] /= f
            short_bear[i] /= f
        elif margin > (1 + θ):
            f = long_t[i] / tot_sh
            short_bull[i] *= f
            short_bear[i] *= f

        port[i] = long_t[i] + short_bull[i] + short_bear[i]

    return port

# Run both strategies
port_static = run_strategy(bw_static, br_static)
port_dynamic = run_strategy(bw_dyn, br_dyn)

# Returns
cum_spx   = (1 + r_spx).cumprod() - 1
cum_static= port_static/port_static[0] - 1
cum_dyn   = port_dynamic/port_dynamic[0] - 1

# Plot on same graph
plt.figure(figsize=(10,5))
plt.plot(dates, cum_spx,    label='S&P 500', color='k', linewidth=2)
plt.plot(dates, cum_static, label='Static (1/3,2/3)', linestyle='--')
plt.plot(dates, cum_dyn,    label='Dynamic', linestyle='-')
plt.title('Static vs Dynamic LETF Pair Strategy vs S&P 500')
plt.xlabel('Date'); plt.ylabel('Cumulative Return')
plt.legend(); plt.grid(True); plt.tight_layout()
plt.show()