# -*- coding: utf-8 -*-
"""experimentation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ejwz4qtvL9jEU95dRJsDdLZYxrypiQAb

SUNDAY April 27th, 6:17 PM
"""

# ─── Cell 1: Strategy & helper definitions ─────────────────────────────
import pandas as pd
import numpy as np
import yfinance as yf
import statsmodels.api as sm

def get_market_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date)
    if data.empty:
        print(f"No data available for {ticker} between {start_date} and {end_date}")
    return data

def calculate_returns(price_data):
    col = 'Adj Close' if 'Adj Close' in price_data.columns else 'Close'
    returns = price_data[col].pct_change().dropna()
    return returns.iloc[:,0] if isinstance(returns, pd.DataFrame) else returns

class ETFPairTradingStrategy:
    def __init__(self, bull_weight, bear_weight,
                 rebalance_threshold=0.2, inout_threshold=0.1):
        total = bull_weight + bear_weight
        self.bull_weight        = bull_weight / total
        self.bear_weight        = bear_weight / total
        self.rebalance_threshold = rebalance_threshold
        self.inout_threshold     = inout_threshold
        self.rebalance_count    = 0
        self.inflow_count       = 0
        self.outflow_count      = 0

    def run_strategy(self, r_bull, r_bear, r_tbill,
                     dates=None, initial_capital=1.0):
        δ, θ = self.rebalance_threshold, self.inout_threshold

        rb, rbr, rt = map(np.asarray, (r_bull, r_bear, r_tbill))
        n = min(len(rb), len(rbr), len(rt))
        dates_idx = pd.DatetimeIndex(dates[:n])

        long_t      = np.zeros(n)
        short_bull  = np.zeros(n)
        short_bear  = np.zeros(n)
        port        = np.zeros(n)
        preturn     = np.zeros(n)

        # Day 0
        long_t[0]     = initial_capital
        short_bull[0] = self.bull_weight * initial_capital
        short_bear[0] = self.bear_weight * initial_capital
        port[0]       = long_t[0] + short_bull[0] + short_bear[0]

        for t in range(1, n):
            # MTM each leg
            short_bull[t] = short_bull[t-1] * (1 - rb[t-1])
            short_bear[t] = short_bear[t-1] * (1 - rbr[t-1])
            long_t[t]     = long_t[t-1] * (1 + rt[t-1])

            # —— rebalance if bull-weight drifts outside [bw-δ, bw+δ]
            total_short = short_bull[t] + short_bear[t]
            curr_bw     = short_bull[t] / total_short
            low, high   = self.bull_weight - δ, self.bull_weight + δ
            if curr_bw < low or curr_bw > high:
                print(f"[δ={δ:.2f}, θ={θ:.2f}] Rebalance @ {dates_idx[t].date()}: "
                      f"{curr_bw:.3f} → {self.bull_weight:.3f}")
                self.rebalance_count += 1
                short_bull[t] = self.bull_weight * total_short
                short_bear[t] = self.bear_weight * total_short

            # —— inflow/outflow if margin ratio outside 1±θ
            total_short = short_bull[t] + short_bear[t]
            ratio       = long_t[t] / total_short
            if ratio < (1 - θ):
                print(f"[δ={δ:.2f}, θ={θ:.2f}] Outflow  @ {dates_idx[t].date()}: "
                      f"margin {ratio:.3f} → 1.000")
                self.outflow_count += 1
                factor = total_short / long_t[t]
                short_bull[t] /= factor
                short_bear[t] /= factor
            elif ratio > (1 + θ):
                print(f"[δ={δ:.2f}, θ={θ:.2f}] Inflow   @ {dates_idx[t].date()}: "
                      f"margin {ratio:.3f} → 1.000")
                self.inflow_count += 1
                factor = long_t[t] / total_short
                short_bull[t] *= factor
                short_bear[t] *= factor

            # Portfolio value & return
            port[t]    = long_t[t] + short_bull[t] + short_bear[t]
            preturn[t] = port[t] / port[t-1] - 1

        df = pd.DataFrame({
            'portfolio_value': port,
            'portfolio_return': preturn
        }, index=dates_idx)

        metrics = {
            'rebalance_count': self.rebalance_count,
            'inflow_count':    self.inflow_count,
            'outflow_count':   self.outflow_count
        }
        return df, metrics

def calculate_portfolio_value_metrics(portfolio_values):
    rets   = portfolio_values.pct_change().dropna()
    n      = len(rets)
    cagr   = (portfolio_values.iloc[-1] / portfolio_values.iloc[0])**(252/n) - 1
    vol    = rets.std() * np.sqrt(252)
    sharpe = rets.mean()/rets.std() * np.sqrt(252)
    cum    = (1+rets).cumprod()
    dd     = (cum/cum.cummax()) - 1
    return {
        'CAGR':   cagr,
        'Volatility': vol,
        'Sharpe': sharpe,
        'MaxDD':  dd.min()
    }

# Cell 2: Run by year and save outputs to files

import os
import matplotlib.pyplot as plt
import pandas as pd

# Ensure output directory exists
output_dir = '/content/strategy_outputs'
os.makedirs(output_dir, exist_ok=True)

# Years to run
years = range(2010, 2025)

# Parameter grid
rebals = [0.2, 0.1, 0.05]
inouts = [0.05, 0.1, 0.2]

for year in years:
    # 1) Download & prep data for the year
    start, end = f'{year}-01-01', f'{year}-12-31'
    spx  = get_market_data('^GSPC', start, end)
    upro = get_market_data('UPRO',  start, end)
    spxu = get_market_data('SPXU',  start, end)
    irx  = get_market_data('^IRX',  start, end)

    r_spx   = calculate_returns(spx)
    r_upro  = calculate_returns(upro)
    r_spxu  = calculate_returns(spxu)
    r_tbill = ((1 + irx['Close']/100.0)**(1/252) - 1).reindex(r_spx.index).ffill()

    # Prepare container for summary data
    records = []

    # 2) Run strategy grid and collect data
    for δ in rebals:
        # Create a figure for this rebalance threshold
        plt.figure(figsize=(8, 4))
        for θ in inouts:
            strat = ETFPairTradingStrategy(1/3, 2/3,
                                           rebalance_threshold=δ,
                                           inout_threshold=θ)
            df, counts = strat.run_strategy(r_upro, r_spxu, r_tbill,
                                             dates=r_spx.index,
                                             initial_capital=10000)
            # cumulative return curve
            cum = (1 + df['portfolio_return']).cumprod() - 1
            plt.plot(cum, label=f'θ={θ:.2f}')
            # collect metrics
            mets = calculate_portfolio_value_metrics(df['portfolio_value'])
            records.append({
                'Year': year,
                'δ': δ, 'θ': θ,
                'CAGR': mets['CAGR'],
                'Sharpe': mets['Sharpe'],
                'MaxDD': mets['MaxDD'],
                'Inflows': counts['inflow_count'],
                'Outflows': counts['outflow_count'],
                'Rebalances': counts['rebalance_count']
            })
        # overlay S&P
        plt.plot((1 + r_spx).cumprod() - 1,
                 label='S&P 500', color='k', linewidth=2)
        plt.title(f'{year} — Cumulative Returns (δ={δ:.2f})')
        plt.xlabel('Date'); plt.ylabel('Cumulative Return')
        plt.legend(); plt.grid(); plt.tight_layout()

        # Save plot for this year and δ
        plot_path = os.path.join(output_dir, f'{year}_returns_delta_{int(δ*100)}.png')
        plt.savefig(plot_path)
        plt.close()

    # 3) VIX plot
    plt.figure(figsize=(8, 4))
    plt.plot(vix := get_market_data('^VIX', start, end)['Close'])
    plt.title(f'{year} — VIX Index (Close)')
    plt.xlabel('Date'); plt.ylabel('VIX')
    plt.grid(); plt.tight_layout()
    vix_path = os.path.join(output_dir, f'{year}_vix.png')
    plt.savefig(vix_path)
    plt.close()

    # 4) Build summary DataFrame and save to CSV
    summary_df = pd.DataFrame(records)
    year_df = summary_df[summary_df['Year'] == year].drop(columns='Year')
    csv_path = os.path.join(output_dir, f'{year}_summary.csv')
    year_df.to_csv(csv_path, index=False)

print(f"All outputs saved under {output_dir}")

"""Final HTML Code - Used for plots in PPT"""



"""# New section

Final code but switched out T-bills for S&P
"""

# HTML Visuals Attempt with S&P as Collateral

import sys
import subprocess

# Install yfinance if not already installed
subprocess.run([sys.executable, "-m", "pip", "install", "yfinance", "--quiet"], check=True)

import os
import io
import base64
import pandas as pd
import numpy as np
import yfinance as yf
import statsmodels.api as sm
import matplotlib.pyplot as plt

# ─── Helper Definitions ─────────────────────────────────────────────────────

def get_market_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date, progress=False)
    if data.empty:
        print(f"No data available for {ticker} between {start_date} and {end_date}")
    return data

def calculate_returns(price_data):
    col = 'Adj Close' if 'Adj Close' in price_data.columns else 'Close'
    returns = price_data[col].pct_change().dropna()
    return returns.iloc[:,0] if isinstance(returns, pd.DataFrame) else returns

class ETFPairTradingStrategy:
    def __init__(self, bull_weight, bear_weight,
                 rebalance_threshold=0.2, inout_threshold=0.1):
        total = bull_weight + bear_weight
        self.bull_weight        = bull_weight / total
        self.bear_weight        = bear_weight / total
        self.rebalance_threshold = rebalance_threshold
        self.inout_threshold     = inout_threshold
        self.rebalance_count    = 0
        self.inflow_count       = 0
        self.outflow_count      = 0

    def run_strategy(self, r_bull, r_bear, r_collateral,
                     dates=None, initial_capital=1.0):
        δ, θ = self.rebalance_threshold, self.inout_threshold
        rb, rbr, rc = map(np.asarray, (r_bull, r_bear, r_collateral))
        n = min(len(rb), len(rbr), len(rc))
        dates_idx = pd.DatetimeIndex(dates[:n])
        long_t = np.zeros(n); short_bull = np.zeros(n); short_bear = np.zeros(n)
        port = np.zeros(n); preturn = np.zeros(n)

        # Day 0
        long_t[0]     = initial_capital
        short_bull[0] = self.bull_weight * initial_capital
        short_bear[0] = self.bear_weight * initial_capital
        port[0]       = long_t[0] + short_bull[0] + short_bear[0]

        for t in range(1, n):
            short_bull[t] = short_bull[t-1] * (1 - rb[t-1])
            short_bear[t] = short_bear[t-1] * (1 - rbr[t-1])
            long_t[t]     = long_t[t-1] * (1 + rc[t-1])

            total_short = short_bull[t] + short_bear[t]
            curr_bw     = short_bull[t] / total_short
            low, high   = self.bull_weight - δ, self.bull_weight + δ
            if curr_bw < low or curr_bw > high:
                self.rebalance_count += 1
                short_bull[t] = self.bull_weight * total_short
                short_bear[t] = self.bear_weight * total_short

            total_short = short_bull[t] + short_bear[t]
            ratio = long_t[t] / total_short
            if ratio < (1 - θ):
                self.outflow_count += 1
                factor = total_short / long_t[t]
                short_bull[t] /= factor; short_bear[t] /= factor
            elif ratio > (1 + θ):
                self.inflow_count += 1
                factor = long_t[t] / total_short
                short_bull[t] *= factor; short_bear[t] *= factor

            port[t]    = long_t[t] + short_bull[t] + short_bear[t]
            preturn[t] = port[t] / port[t-1] - 1

        df = pd.DataFrame({'portfolio_value': port, 'portfolio_return': preturn}, index=dates_idx)
        metrics = {
            'rebalance_count': self.rebalance_count,
            'inflow_count':    self.inflow_count,
            'outflow_count':   self.outflow_count
        }
        return df, metrics

def calculate_portfolio_value_metrics(portfolio_values):
    rets = portfolio_values.pct_change().dropna()
    n    = len(rets)
    cagr = (portfolio_values.iloc[-1] / portfolio_values.iloc[0])**(252/n) - 1
    vol  = rets.std() * np.sqrt(252)
    sharpe = rets.mean()/rets.std() * np.sqrt(252)
    cum = (1 + rets).cumprod()
    dd  = (cum / cum.cummax()) - 1
    return {'CAGR': cagr, 'Sharpe': sharpe, 'MaxDD': dd.min()}

# ─── Generate HTML Reports (using S&P as collateral) ───────────────────────

output_dir = 'strategy_reports'
os.makedirs(output_dir, exist_ok=True)

years  = range(2010, 2025)
rebals = [0.2, 0.1, 0.05]
inouts= [0.05, 0.1, 0.2]
light_green, light_yellow, light_red = '#d5ead1', '#fff2cc', '#f8cecc'

def style_bg(v, metric):
    if metric == 'CAGR':
        color = light_green if v>=0.10 else (light_yellow if v>=0.05 else light_red)
    elif metric == 'Sharpe':
        color = light_green if v>=0.75 else (light_yellow if v>=0.30 else light_red)
    else:
        color = light_green if v>=-0.05 else (light_yellow if v>=-0.10 else light_red)
    return f'background-color:{color};color:black'

for year in years:
    start, end = f'{year}-01-01', f'{year}-12-31'
    spx  = get_market_data('^GSPC', start, end)
    upro = get_market_data('UPRO', start, end)
    spxu = get_market_data('SPXU', start, end)
    irx  = get_market_data('^IRX', start, end)

    r_spx   = calculate_returns(spx)
    r_upro  = calculate_returns(upro)
    r_spxu  = calculate_returns(spxu)
    # Use S&P returns instead of T-bills
    r_collateral = r_spx

    # Compute S&P metrics
    spx_port = (1 + r_spx).cumprod()
    spx_mets = calculate_portfolio_value_metrics(spx_port)

    records, images = [], {}

    # Cumulative returns plots
    for δ in rebals:
        buf = io.BytesIO(); plt.figure(figsize=(8,4))
        for θ in inouts:
            strat = ETFPairTradingStrategy(1/3,2/3,δ,θ)
            df, cnt = strat.run_strategy(r_upro, r_spxu, r_collateral,
                                         dates=r_spx.index, initial_capital=10000)
            cum = (1 + df['portfolio_return']).cumprod() - 1
            plt.plot(cum, label=f'θ={θ:.2f}')
            mets = calculate_portfolio_value_metrics(df['portfolio_value'])
            records.append({'Year': year, 'δ': δ, 'θ': θ, **mets, **cnt})
        plt.plot(spx_port - 1, label='S&P 500', color='k', linewidth=2)
        plt.title(f'{year} Returns δ={δ:.2f}')
        plt.legend(); plt.grid(); plt.tight_layout()
        plt.savefig(buf, format='png'); plt.close()
        images[f'δ={δ:.2f}'] = base64.b64encode(buf.getvalue()).decode()

    # VIX plot
    buf = io.BytesIO(); plt.figure(figsize=(8,4))
    plt.plot(get_market_data('^VIX', start, end)['Close'])
    plt.title(f'{year} VIX'); plt.grid(); plt.tight_layout()
    plt.savefig(buf, format='png'); plt.close()
    images['VIX'] = base64.b64encode(buf.getvalue()).decode()

    # Build and style tables
    df_year = pd.DataFrame(records).query("Year == @year").drop(columns='Year')
    pc = df_year.pivot(index='δ', columns='θ', values='CAGR')
    ps = df_year.pivot(index='δ', columns='θ', values='Sharpe')
    pm = df_year.pivot(index='δ', columns='θ', values='MaxDD')
    pcount = df_year.pivot(index='δ', columns='θ', values=['inflow_count','outflow_count','rebalance_count'])

    # Compose HTML
    html = f"<html><head><title>Report {year}</title></head><body>"
    html += f"<h1>Report for {year}</h1>"
    html += "<h2>S&P 500 Metrics</h2><ul>"
    html += f"<li>CAGR: {spx_mets['CAGR']:.2%}</li>"
    html += f"<li>Sharpe: {spx_mets['Sharpe']:.2f}</li>"
    html += f"<li>MaxDD: {spx_mets['MaxDD']:.2%}</li>"
    html += "</ul>"

    for lbl, img in images.items():
        html += f"<h2>{lbl}</h2><img src='data:image/png;base64,{img}'/><br/>"
    html += "<h2>CAGR</h2>" + pc.style.format("{:.2%}").map(lambda v: style_bg(v,'CAGR')).to_html()
    html += "<h2>Sharpe</h2>" + ps.style.format("{:.2f}").map(lambda v: style_bg(v,'Sharpe')).to_html()
    html += "<h2>MaxDD</h2>" + pm.style.format("{:.2%}").map(lambda v: style_bg(v,'MaxDD')).to_html()
    html += "<h2>Trade Counts</h2>" + pcount.to_html()
    html += "</body></html>"

    with open(os.path.join(output_dir, f"{year}_report.html"), 'w') as f:
        f.write(html)

print("Reports saved to", output_dir)

from google.colab import files
files.download('strategy_reports/2010_report.html')
files.download('strategy_reports/2011_report.html')
files.download('strategy_reports/2012_report.html')
files.download('strategy_reports/2013_report.html')
files.download('strategy_reports/2014_report.html')
files.download('strategy_reports/2015_report.html')
files.download('strategy_reports/2016_report.html')
files.download('strategy_reports/2017_report.html')
files.download('strategy_reports/2018_report.html')
files.download('strategy_reports/2019_report.html')
files.download('strategy_reports/2020_report.html')
files.download('strategy_reports/2021_report.html')
files.download('strategy_reports/2022_report.html')
files.download('strategy_reports/2023_report.html')
files.download('strategy_reports/2024_report.html')