# -*- coding: utf-8 -*-
"""base_strategy_test

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FU63BknGyBIkYWtTn_i-BfSxHs6eMlXG
"""

import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt
import statsmodels.api as sm

def get_market_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date)
    if data.empty:
        print(f"No data available for {ticker} between {start_date} and {end_date}")
    else:
        print(f"Downloaded data for {ticker}: {len(data)} rows")
    return data

def calculate_returns(price_data):
    if 'Adj Close' in price_data.columns:
        col = 'Adj Close'
    elif 'Close' in price_data.columns:
        col = 'Close'
    else:
        raise KeyError(f"Expected 'Adj Close' or 'Close' column, got {price_data.columns.tolist()}")
    returns = price_data[col].pct_change().dropna()
    if isinstance(returns, pd.DataFrame):
        if returns.shape[1] == 1:
            returns = returns.iloc[:, 0]
        else:
            raise ValueError(f"Expected single-column returns, got {returns.columns}")
    return returns

def estimate_leverage_parameters(etf_returns, market_returns):
    idx = etf_returns.index.intersection(market_returns.index)
    y = etf_returns.loc[idx]
    X = sm.add_constant(market_returns.loc[idx])
    model = sm.OLS(y, X).fit()
    alpha, beta = model.params
    print(f"Estimated alpha={alpha:.6f}, beta={beta:.6f}, R²={model.rsquared:.4f}")
    return alpha, beta, model.resid

class ETFPairTradingStrategy:
    def __init__(self, bull_weight, bear_weight,
                 rebalance_threshold=0.2, inout_threshold=0.1):
        total = bull_weight + bear_weight
        self.bull_weight = bull_weight / total
        self.bear_weight = bear_weight / total
        self.rebalance_threshold = rebalance_threshold
        self.inout_threshold = inout_threshold
        self.rebalance_count = 0
        self.inflow_count = 0
        self.outflow_count = 0
        self.rebalance_value_impact = 0.0
        self.inflow_value_impact = 0.0
        self.outflow_value_impact = 0.0

    def run_strategy(self, r_bull, r_bear, r_tbill,
                     dates=None, initial_capital=1.0):
        rb = np.asarray(r_bull)
        rbr = np.asarray(r_bear)
        rt = np.asarray(r_tbill)
        n = min(len(rb), len(rbr), len(rt))
        rb, rbr, rt = rb[:n], rbr[:n], rt[:n]
        dates_idx = pd.DatetimeIndex(dates[:n]) if dates is not None else pd.RangeIndex(n)

        long_t    = np.zeros(n)
        short_bull= np.zeros(n)
        short_bear= np.zeros(n)
        port      = np.zeros(n)
        preturn   = np.zeros(n)

        # Day 0
        long_t[0]     = initial_capital
        short_bull[0] = self.bull_weight * initial_capital
        short_bear[0] = self.bear_weight * initial_capital
        port[0]       = long_t[0] + short_bull[0] + short_bear[0]

        for t in range(1, n):
            # mark-to-market each leg
            short_bull[t] = short_bull[t-1] * (1 - rb[t-1].item())
            short_bear[t] = short_bear[t-1] * (1 - rbr[t-1].item())
            long_t[t]     = long_t[t-1] * (1 + rt[t-1].item())

            total_short = short_bull[t] + short_bear[t]
            curr_bw     = short_bull[t] / total_short if total_short>0 else self.bull_weight

            # —— rebalance leg ratio if outside [bw-δ, bw+δ]
            low, high = self.bull_weight - self.rebalance_threshold, self.bull_weight + self.rebalance_threshold
            if curr_bw < low or curr_bw > high:
                port_before = long_t[t] + total_short
                amount_traded = 2 * abs(self.bull_weight - curr_bw) * total_short
                short_bull[t] = self.bull_weight * total_short
                short_bear[t] = self.bear_weight * total_short
                self.rebalance_count += 1
                port_after = long_t[t] + short_bull[t] + short_bear[t]
                self.rebalance_value_impact += (port_after - port_before)
                print(f"Rebalance @ {dates_idx[t].date()}: traded ${amount_traded:.2f}, Δvalue ${(port_after-port_before):.2f}")

            # —— inflow/outflow if margin ratio outside 1±θ
            total_short = short_bull[t] + short_bear[t]
            ratio       = long_t[t] / total_short if total_short>0 else 1.0
            port_before = long_t[t] + total_short

            if ratio < (1 - self.inout_threshold):
                amount_traded = abs(1 - ratio) * total_short
                factor = total_short / long_t[t]
                short_bull[t] /= factor
                short_bear[t] /= factor
                self.outflow_count += 1
                port_after = long_t[t] + short_bull[t] + short_bear[t]
                self.outflow_value_impact += (port_after - port_before)
                print(f"Outflow  @ {dates_idx[t].date()}: traded ${amount_traded:.2f}, Δvalue ${(port_after-port_before):.2f}")

            elif ratio > (1 + self.inout_threshold):
                amount_traded = abs(ratio - 1) * total_short
                factor = long_t[t] / total_short
                short_bull[t] *= factor
                short_bear[t] *= factor
                self.inflow_count += 1
                port_after = long_t[t] + short_bull[t] + short_bear[t]
                self.inflow_value_impact += (port_after - port_before)
                print(f"Inflow   @ {dates_idx[t].date()}: traded ${amount_traded:.2f}, Δvalue ${(port_after-port_before):.2f}")

            port[t]     = long_t[t] + short_bull[t] + short_bear[t]
            preturn[t]  = (port[t]/port[t-1]) - 1 if port[t-1]!=0 else 0

        df = pd.DataFrame({
            'portfolio_value': port,
            'portfolio_return': preturn,
            'long_tbill': long_t,
            'short_bull': short_bull,
            'short_bear': short_bear
        }, index=dates_idx)

        metrics = {
            'rebalance_count': self.rebalance_count,
            'inflow_count':    self.inflow_count,
            'outflow_count':   self.outflow_count,
            'rebalance_value_impact': self.rebalance_value_impact,
            'inflow_value_impact':    self.inflow_value_impact,
            'outflow_value_impact':   self.outflow_value_impact,
            'final_portfolio_value':  port[-1]
        }
        return df, metrics

def calculate_portfolio_value_metrics(portfolio_values):
    rets = portfolio_values.pct_change().dropna()
    n    = len(rets)

    # CAGR
    ann_ret = (portfolio_values.iloc[-1]/portfolio_values.iloc[0])**(252/n) - 1
    # Vol
    vol     = rets.std() * np.sqrt(252)
    # Sharpe
    sharpe  = (rets.mean()/rets.std()) * np.sqrt(252) if rets.std()>0 else 0
    # Max drawdown
    cum = (1+rets).cumprod()
    dd  = (cum/cum.cummax()) - 1
    mxdd = dd.min()

    return {
        'annualized_return': ann_ret,
        'volatility':        vol,
        'sharpe_ratio':      sharpe,
        'max_drawdown':      mxdd
    }

def main():
    # 1) download
    start, end = '2010-01-01','2010-12-31'
    spx  = get_market_data('^GSPC', start, end)
    upro = get_market_data('UPRO', start, end)
    spxu = get_market_data('SPXU', start, end)

    # 2) returns
    r_spx  = calculate_returns(spx)
    r_upro = calculate_returns(upro)
    r_spxu = calculate_returns(spxu)

    # 3) fit alphas/betas
    estimate_leverage_parameters(r_upro, r_spx)
    estimate_leverage_parameters(r_spxu, r_spx)

    # 4) T-bill ~2%
    drf = (1+0.02)**(1/252)-1
    r_tbill = pd.Series(drf, index=r_spx.index)

    # 5) run strategy
    initial_capital = 10000.0
    strat = ETFPairTradingStrategy(1/3, 2/3, rebalance_threshold=0.1, inout_threshold=0.1)
    res, strat_mets = strat.run_strategy(r_upro, r_spxu, r_tbill,
                                         dates=r_spx.index,
                                         initial_capital=initial_capital)

    # 6) normalize raw portfolio_value (starts @20k) → start @10k
    pv_raw = res['portfolio_value']
    pv = pv_raw * (initial_capital / pv_raw.iloc[0])

    # 7) build a 10k‐start S&P 500 buy‐and‐hold for comparison
    spx_value = initial_capital * (1 + r_spx).cumprod()

    # 8) recompute metrics on the normalized portfolio
    val_mets = calculate_portfolio_value_metrics(pv)
    print("\n=== Strategy vs. Buy-and-Hold Metrics ===")
    print(f"Strategy:  Ann Ret {val_mets['annualized_return']:.2%}, Vol {val_mets['volatility']:.2%}, Sharpe {val_mets['sharpe_ratio']:.2f}, MaxDD {val_mets['max_drawdown']:.2%}")
    print(f"S&P500 BH: Ann Ret {(spx_value.iloc[-1]/spx_value.iloc[0])**(252/len(r_spx))-1:.2%}")

    # 9) plot both on one chart
    plt.figure(figsize=(12,6))
    plt.plot(pv.index,       pv,        label='Strategy Value (start 10k)', linewidth=2)
    plt.plot(spx_value.index, spx_value, label='S&P 500 B&H (start 10k)')
    plt.title('Strategy vs. S&P 500 (Portfolio Value)')
    plt.xlabel('Date')
    plt.ylabel('Value ($)')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

if __name__ == '__main__':
    main()