# -*- coding: utf-8 -*-
"""deviation_ranker_and_regression.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S34qC9BB14PfQCNdQrxL6cvbqQB8ekFJ

LETF Selector for top 32 + OLS Regression Runner
"""

!pip install selenium --quiet

"""Second piece of code more important - ranks all LETFs by leverage deviation.
First code is just preliminary analysis

Ranks 15 initial LETFs for biggest deviators
"""

import yfinance as yf
import pandas as pd
import statsmodels.api as sm
from datetime import datetime

# Defining LETFs
letf_data = [
    {'ticker': 'SSO', 'leverage': 2.0, 'index_ticker': '^GSPC'},
    {'ticker': 'QLD', 'leverage': 2.0, 'index_ticker': '^NDX'},
    {'ticker': 'UPRO', 'leverage': 3.0, 'index_ticker': '^GSPC'},
    {'ticker': 'SPXL', 'leverage': 3.0, 'index_ticker': '^GSPC'},
    {'ticker': 'TQQQ', 'leverage': 3.0, 'index_ticker': '^NDX'},
    {'ticker': 'SOXL', 'leverage': 3.0, 'index_ticker': '^SOX'},
    {'ticker': 'FAS', 'leverage': 3.0, 'index_ticker': 'XLF'},  # Using XLF as proxy for ^RLF
    {'ticker': 'TNA', 'leverage': 3.0, 'index_ticker': '^RUT'},
    {'ticker': 'SPXU', 'leverage': -3.0, 'index_ticker': '^GSPC'},
    {'ticker': 'SQQQ', 'leverage': -3.0, 'index_ticker': '^NDX'},
    {'ticker': 'SOXS', 'leverage': -3.0, 'index_ticker': '^SOX'},
    {'ticker': 'FAZ', 'leverage': -3.0, 'index_ticker': 'XLF'},  # Using XLF as proxy for ^RLF
    {'ticker': 'TZA', 'leverage': -3.0, 'index_ticker': '^RUT'},
    {'ticker': 'SDS', 'leverage': -2.0, 'index_ticker': '^GSPC'},
    {'ticker': 'QID', 'leverage': -2.0, 'index_ticker': '^NDX'},
]

#Fetch data for LETFs and indices
def fetch_data(ticker, period='max'):
    try:
        df = yf.download(ticker, period=period, progress=False)
        if not df.empty:
            print(f"Data retrieved for {ticker} from {df.index[0].strftime('%Y-%m-%d')}")
            print(f"Columns for {ticker}: {df.columns}")
            # Handle multi-level or single-level columns
            if isinstance(df.columns, pd.MultiIndex):
                close = df[('Close', ticker)]
            else:
                close = df['Close']
            return close
        else:
            print(f"No data found for {ticker}")
            return None
    except Exception as e:
        print(f"Error downloading {ticker}: {e}")
        return None

# Regression for empirical leverage
def calculate_leverage(letf_returns, index_returns):
    # Align returns by dropping rows with any NaN values
    aligned = pd.concat([letf_returns, index_returns], axis=1).dropna()
    if len(aligned) < 2:
        return None
    X = aligned.iloc[:, 1]  # Index returns
    y = aligned.iloc[:, 0]  # LETF returns
    X = sm.add_constant(X)  # Add intercept
    model = sm.OLS(y, X).fit()
    return model.params[1]  # Return beta (slope)

# Main function to process LETFs and rank them
def leverage_rank_maker():
    letf_prices = {}
    letf_returns = {}
    index_prices = {}
    results = []

    # Fetch data for each LETF and its index
    for item in letf_data:
        ticker = item['ticker']
        index_ticker = item['index_ticker']

        # Fetch LETF data
        letf_price = fetch_data(ticker)
        if letf_price is not None:
            letf_prices[ticker] = letf_price
            letf_returns[ticker] = letf_price.pct_change(fill_method=None)

        # Fetch index data (only once per unique index)
        if index_ticker not in index_prices:
            index_price = fetch_data(index_ticker)
            if index_price is not None:
                index_prices[index_ticker] = index_price

        # Calculate empirical leverage if both LETF and index data exist
        if ticker in letf_returns and index_ticker in index_prices:
            index_return = index_prices[index_ticker].pct_change(fill_method=None)
            beta = calculate_leverage(letf_returns[ticker], index_return)
            if beta is not None:
                leverage_diff = abs(beta - item['leverage'])
                results.append({
                    'Ticker': ticker,
                    'Stated Leverage': item['leverage'],
                    'Empirical Leverage': round(beta, 3),
                    'Leverage Difference': round(leverage_diff, 3),
                    'Index': index_ticker
                })
            else:
                print(f"Insufficient data to calculate leverage for {ticker}")
        else:
            print(f"Skipping leverage calculation for {ticker} due to missing data")

    # Create DataFrames
    if letf_prices:
        letf_prices_df = pd.DataFrame(letf_prices)
        letf_returns_df = pd.DataFrame(letf_returns)
    else:
        letf_prices_df, letf_returns_df = None, None

    # Create results DataFrame and rank
    if results:
        results_df = pd.DataFrame(results)
        results_df['Rank'] = results_df['Leverage Difference'].rank()
        results_df = results_df.sort_values('Rank')
    else:
        results_df = None
        print("No leverage results calculated.")

    # Save to CSV
    if letf_prices_df is not None:
        letf_prices_df.to_csv('letf_prices.csv')
        letf_returns_df.to_csv('letf_returns.csv')
        print("Saved prices and returns to letf_prices.csv and letf_returns.csv")
    if results_df is not None:
        results_df.to_csv('leverage_rankings.csv', index=False)
        print("Saved leverage rankings to leverage_rankings.csv")

    return letf_prices_df, letf_returns_df, results_df

# Run the leverage rank maker
prices_df, returns_df, rankings_df = leverage_rank_maker()

# Display results
if rankings_df is not None:
    print("\nLeverage Rankings:")
    print(rankings_df)
if prices_df is not None:
    print("\nClose Prices (first 5 rows):")
    print(prices_df.head())
    print("\nDaily Returns (first 5 rows):")
    print(returns_df.head())

import yfinance as yf
import pandas as pd
import statsmodels.api as sm
from datetime import datetime, timedelta
import logging
import uuid

# Suppress yfinance logs
logging.getLogger('yfinance').setLevel(logging.CRITICAL)

# Define LETF tickers, target leverage, and underlying indices/stocks
letf_data = [
    {'ticker': 'SSO', 'leverage': 2.0, 'index_ticker': '^GSPC', 'start_date': '2006-06-21'},
    {'ticker': 'QLD', 'leverage': 2.0, 'index_ticker': '^NDX', 'start_date': '2006-06-21'},
    {'ticker': 'UPRO', 'leverage': 3.0, 'index_ticker': '^GSPC', 'start_date': '2009-06-25'},
    {'ticker': 'SPXL', 'leverage': 3.0, 'index_ticker': '^GSPC', 'start_date': '2008-11-05'},
    {'ticker': 'TQQQ', 'leverage': 3.0, 'index_ticker': '^NDX', 'start_date': '2010-02-11'},
    {'ticker': 'SOXL', 'leverage': 3.0, 'index_ticker': '^SOX', 'start_date': '2010-03-11'},
    {'ticker': 'FAS', 'leverage': 3.0, 'index_ticker': 'XLF', 'start_date': '2008-11-19'},
    {'ticker': 'TNA', 'leverage': 3.0, 'index_ticker': '^RUT', 'start_date': '2008-11-19'},
    {'ticker': 'SPXU', 'leverage': -3.0, 'index_ticker': '^GSPC', 'start_date': '2009-06-25'},
    {'ticker': 'SQQQ', 'leverage': -3.0, 'index_ticker': '^NDX', 'start_date': '2010-02-11'},
    {'ticker': 'SOXS', 'leverage': -3.0, 'index_ticker': '^SOX', 'start_date': '2010-03-11'},
    {'ticker': 'FAZ', 'leverage': -3.0, 'index_ticker': 'XLF', 'start_date': '2008-11-19'},
    {'ticker': 'TZA', 'leverage': -3.0, 'index_ticker': '^RUT', 'start_date': '2008-11-19'},
    {'ticker': 'SDS', 'leverage': -2.0, 'index_ticker': '^GSPC', 'start_date': '2006-07-13'},
    {'ticker': 'QID', 'leverage': -2.0, 'index_ticker': '^NDX', 'start_date': '2006-07-13'},
    # Additional index-based LETFs
    {'ticker': 'TECL', 'leverage': 3.0, 'index_ticker': 'XLK', 'start_date': '2008-12-17'},
    {'ticker': 'TECS', 'leverage': -3.0, 'index_ticker': 'XLK', 'start_date': '2008-12-17'},
    {'ticker': 'MIDU', 'leverage': 3.0, 'index_ticker': '^MID', 'start_date': '2009-01-08'},
    {'ticker': 'MIDZ', 'leverage': -3.0, 'index_ticker': '^MID', 'start_date': '2009-01-08'},
    {'ticker': 'LABU', 'leverage': 3.0, 'index_ticker': 'XBI', 'start_date': '2015-05-28'},
    {'ticker': 'LABD', 'leverage': -3.0, 'index_ticker': 'XBI', 'start_date': '2015-05-28'},
    {'ticker': 'RETL', 'leverage': 3.0, 'index_ticker': 'XRT', 'start_date': '2010-07-14'},
    {'ticker': 'RETS', 'leverage': -3.0, 'index_ticker': 'XRT', 'start_date': '2010-07-14'},
    # Single-stock LETFs
    {'ticker': 'NVDL', 'leverage': 2.0, 'index_ticker': 'NVDA', 'start_date': '2022-12-12'},
    {'ticker': 'NVDU', 'leverage': 2.0, 'index_ticker': 'NVDA', 'start_date': '2023-08-22'},
    {'ticker': 'NVDD', 'leverage': -1.0, 'index_ticker': 'NVDA', 'start_date': '2023-08-22'},
    {'ticker': 'NVDX', 'leverage': 2.0, 'index_ticker': 'NVDA', 'start_date': '2023-10-26'},
    {'ticker': 'TSLL', 'leverage': 2.0, 'index_ticker': 'TSLA', 'start_date': '2022-08-09'},
    {'ticker': 'TSLS', 'leverage': -1.0, 'index_ticker': 'TSLA', 'start_date': '2022-08-09'},
    {'ticker': 'AAPU', 'leverage': 2.0, 'index_ticker': 'AAPL', 'start_date': '2022-08-09'},
    {'ticker': 'AAPD', 'leverage': -1.0, 'index_ticker': 'AAPL', 'start_date': '2022-08-09'},
    {'ticker': 'AMZU', 'leverage': 2.0, 'index_ticker': 'AMZN', 'start_date': '2022-08-09'},
    {'ticker': 'AMZD', 'leverage': -1.0, 'index_ticker': 'AMZN', 'start_date': '2022-08-09'},
]

# Function to fetch data for a specific year
def fetch_data(ticker, start_date, end_date):
    try:
        df = yf.download(ticker, start=start_date, end=end_date, progress=False)
        if not df.empty:
            return df['Close'] if 'Close' in df.columns else df[('Close', ticker)]
        return None
    except:
        return None

# Function to calculate empirical leverage using regression
def calculate_leverage(letf_returns, index_returns):
    aligned = pd.concat([letf_returns, index_returns], axis=1).dropna()
    if len(aligned) < 2:
        return None
    X = aligned.iloc[:, 1]
    y = aligned.iloc[:, 0]
    X = sm.add_constant(X)
    model = sm.OLS(y, X).fit()
    return model.params.iloc[1]

# Function to calculate all-time leverage deviations
def all_time_leverage_deviations():
    results = []
    for item in letf_data:
        ticker = item['ticker']
        start_date = item['start_date']
        end_date = '2025-01-01'
        letf_price = fetch_data(ticker, start_date, end_date)
        index_price = fetch_data(item['index_ticker'], start_date, end_date)
        if letf_price is not None and index_price is not None:
            letf_returns = letf_price.pct_change(fill_method=None)
            index_returns = index_price.pct_change(fill_method=None)
            beta = calculate_leverage(letf_returns, index_returns)
            if beta is not None:
                leverage_diff = abs(beta - item['leverage'])
                results.append({
                    'Ticker': ticker,
                    'Target Leverage': item['leverage'],
                    'Empirical Leverage': round(beta, 3),
                    'Leverage Difference': round(leverage_diff, 3),
                    'Index': item['index_ticker'],
                    'Rank': None
                })
    results_df = pd.DataFrame(results)
    results_df['Rank'] = results_df['Leverage Difference'].rank(ascending=False)
    results_df = results_df.sort_values('Rank')
    results_df.to_csv('leverage_deviations_all_time.csv', index=False)
    return results_df

# Function to calculate annual leverage deviations
def annual_leverage_deviations():
    years = range(2005, 2025)
    all_results = {}

    for year in years:
        start_date = datetime(year, 1, 1)
        end_date = datetime(year, 12, 31) + timedelta(days=1)
        results = []

        for item in letf_data:
            ticker = item['ticker']
            index_ticker = item['index_ticker']
            if datetime.strptime(item['start_date'], '%Y-%m-%d').year > year:
                continue
            letf_price = fetch_data(ticker, start_date, end_date)
            index_price = fetch_data(index_ticker, start_date, end_date)
            if letf_price is not None and index_price is not None:
                letf_returns = letf_price.pct_change(fill_method=None)
                index_returns = index_price.pct_change(fill_method=None)
                beta = calculate_leverage(letf_returns, index_returns)
                if beta is not None:
                    leverage_diff = abs(beta - item['leverage'])
                    results.append({
                        'Ticker': ticker,
                        'Target Leverage': item['leverage'],
                        'Empirical Leverage': round(beta, 3),
                        'Leverage Difference': round(leverage_diff, 3),
                        'Index': index_ticker,
                        'Rank': None
                    })

        if results:
            results_df = pd.DataFrame(results)
            results_df['Rank'] = results_df['Leverage Difference'].rank(ascending=False)
            results_df = results_df.sort_values('Rank').head(5)
            all_results[year] = results_df
            results_df.to_csv(f'leverage_deviations_{year}.csv', index=False)

    return all_results

# Run the analysis
all_time_results = all_time_leverage_deviations()
annual_results = annual_leverage_deviations()

# Output annual results
for year, df in annual_results.items():
    print(f"\nYear {year} Top 5 Deviators:")
    print(df[['Ticker', 'Target Leverage', 'Empirical Leverage', 'Leverage Difference', 'Index', 'Rank']].to_string(index=False))

# Output all-time results
print("\nAll-Time Leverage Deviations:")
print(all_time_results[['Ticker', 'Target Leverage', 'Empirical Leverage', 'Leverage Difference', 'Index', 'Rank']].to_string(index=False))
